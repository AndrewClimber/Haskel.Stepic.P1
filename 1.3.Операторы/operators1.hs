-- Операторы в Haskell
module Demo where

-- префиксный стиль
isMax x y = max x y

-- операторы в инфиксном
isPlus x y = x + y

-- но операторы можно вызывать в функциональном стиле.
-- а функции в операторном
isFuncStylePlus x y = (+) x y

isOperStyleMax x y = x `max` y

-- Все операторы в Haskell бинарные. Т.е. принимают ровно 2 аргумента
-- за исключением унарного минуса. Который исп. для задания отрицательного числа.
-- - 7
-- бинарный минус тоже есть. (-) 5 3
-- max (-5) 5 из-за этого бинарный минус приходится заключать в скобки
-- дюбой оператор имеет приоритет меньше - чем у функции
-- sin 4 + 5 . сначала синус - затем плюс
{-
задание ассоциативности функций и операторов
infixr 8 ^, `logBase` :правая ассоциативность с приоритетом 8
infixl 7 *, /, `div`, `mod`  :левая ассоциативность с приоритетом 7
infix 4 ==, /=, >, >=, <, <= :нет ассоциативности приоритет 4.цепочки строить нельзя
-}
{-
infixr 9  .
infixl 9  !!
infixr 8  ^, ^^, **
infixl 7  *, /, `quot`, `rem`, `div`, `mod`, :%, %
infixl 6  +, -
infixr 5  :, ++
infix  4  ==, /=, <, <=, >=, >, `elem`, `notElem`
infixr 3  &&
infixr 2  ||
infixl 1  >>, >>=
infixr 1  =<<
infixr 0  $, $!, `seq`
-}
{-
 В Haskell нет встроенных операторов. Все его операторы определены в стандартной библиотеке.
 Программист может сам создавать собственные операторы. Для этого используется набор сомволов :
 ! # $ % * + . / < = > ? @ \ ^ | : - ~
-}
-- создадим собственный оператор

-- зададим оператор суммы квадратов
infixl 6 *+* -- умножение плюс умножение
-- теперь определим оператор суммы квадратов
-- сделаем это в операторном синтаксисе
-- a и b - это параметры
a *+* b = a^2 + b^2
-- Пример вызова : 2 *+* 5
-- либо : (*+*) 2 5

-- Задание создать оператор модуль разности |-|
infixl 6 |-|
a |-| b = abs(a - b)

-- стырил в решениях. понравилось
infixl 6 |-|
x |-| y = max x y - min x y

-- а как вот это работает непонятно :(
infixl 6 |-|
(|-|) = (abs .) . (-)

{-
еще варианты
x |-| y = abs $ x - y
x |-| y = if (x-y) > 0 then (x-y) else (y-x)

(|-|) :: Int -> Int -> Int
x |-| y = abs (x - y)

-}



-- компактный синтаксис применения оператра к одному из своих аргументов
-- сечение оператора . связываем левый аргумент оператора деление.  получается функция одного аргумента
--
-- (2 /) 4
-- 0.5
-- можно связать в функциональном стиле не только левый, но и правый аргумент.
-- (/ 2) 4
-- 2
-- синтаксис сечения требует обязательного использования круглых скобок.
-- но у ператора минус - нет правого сечения
-- (- 2) - это не сечение. это применение унарного минуса к двойке.
-- -2

{-
  Применение функции к своему аргументу записывается так :
  слева ф-я. справа аргумент . а между ними знак пробела : func x
  пробел тут рассматривается - как специальный оператор.
  а можно сделать и по другому.  Определим следующий оператор
  f $ x = f x
  это стандартное определение бинарного оператора.
  тело выглядит - как ф-я f примененная к аргументу x
  это позволяет писать применение не через пробел - а через $
  На самом деле такой оператор определен в стандартной библиотеке.
  sin 0
  0.0
  sin $ 0
  0.0
  Кажется - что это бессмыстленно и избыточно. Однако у $ имеется самый низкий
  из всех возможных приоритет. Его применение позволяет избавиться от избыточных
  скобок.
  sin (pi/2)
  1.0
  sin $ pi/2
  1.0
  оператор $ - Он говорит что-то вроде «считаем, что всё, что написано справа, стоит в скобках».
  $ - имеет правую ассоциативность : infixr 0 $
  поэтому даже в более сложных случаях он позволяет избавиться от скобок
  функции f, g, h и аргументы x, y
  причем g - функция двух аргументов
  а к результату g x (h y) - применяется ф-я f
  f (g x (h y) ) == f $ g x (h y) == f $ g x $ h y
  правоассоциативность $ - говорит - что скобки надо расставить вправо
-}
