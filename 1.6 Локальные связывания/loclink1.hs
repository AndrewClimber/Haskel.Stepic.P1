-- Отступы в Haskell создают двумерный синтаксис
-- Простое правило - увеличение отступа - безопасно. а уменьшение - может привести к проблемам
-- увеличение отступа - это продолжение объявления на предыдущей строке
-- Пример : ф-я roots, которая находит корни квадратного уравнения.
module Demo where
roots :: Double->Double->Double -- нулевой отступ
              ->(Double, Double)
roots a b c = -- нулевой отступ - началось новое глобальное объявление.
        (
            (-b - sqrt (b^2 - 4 * a * c)) / ( 2 * a)
            ,
            (-b + sqrt (b^2 - 4 * a * c)) / (2 * a)
        )


-- вторая версия ф-и roots. С локальным связыванием let in
roots' a b c =
    let d = sqrt (b^2 - 4 * a * c ) in
        ((-b - d) / (2 * a), (-b + d) / (2 * a))

-- третья уже моя версия roots. с where
roots'' a b c =
    let d = sqrt (b^2 - 4 * a * c ) in
        ((-b - d) / a2, (-b + d) / a2) where a2 = (2 * a)

-- пример множества связывания . разделение через ;
-- порядок связывания неважен. можно было бы делать даже взаимную рекурсию
-- в Haskell многме выражения могут заключаться в {} и разделяться ;
-- но с отступами нагляднее
roots''' a b c =
    let {d = sqrt(b^2 - 4 * a * c); x1 = (-b -d) / (2 * a); x2 = (-b + d) / (2 * a)}
    in (x1, x2)

-- Вариант с отступами очень нагляден.
roots'''' a b c =
    let
        d = sqrt $ b^2 - 4 * a * c
        x1 = (-b - d) / aTwice
        x2 = (-b + d) / aTwice
        aTwice = 2 * a
    in (x1, x2)

-- вариант с where . прям как в алгебре    
roots''''' a b c =
    (x1, x2)
    where
        d = sqrt $ b^2 - 4 * a * c
        x1 = (-b - d) / aTwice
        x2 = (-b + d) / aTwice
        aTwice = 2 * a
