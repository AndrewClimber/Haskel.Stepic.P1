-- можно ограничить полиморфизм ф-и с помощью явного указания ее типа.
-- Пример :
module Demo where
-- mono - похожа на ф-ю id, но в отличие от ее она мономорфная
-- т.к. явно указан тип. id может работать с разными типами. mono - только с типом Char
    mono :: Char -> Char
    mono x = x

    
-- можем частично ограничивать полиморфизм ф-и
-- semiMono похожа на ф-ю const. Два аргумента и 2-й игнорируется.
-- 1-й аргумент может иметь тип только Char, 2-й может быть любого типа.
-- эта ф-я полиморфна по 2-му аргументу
    semiMono :: Char -> a -> Char
    semiMono x y = x


-- если не указываем тип явно - то Haskell вывоит наиболее общий тип.
    semiMono' x y = x
{-
    Demo> :t semiMono
    semiMono :: Char -> a -> Char

    Видим, что тип стал полиморфным.
    *Demo> :t semiMono'
    semiMono' :: p1 -> p2 -> p1
-}        

-- ФВП - это ф-я, которая принимает в качестве аргумента другую ф-ю
-- функция $ - является ФВП
-- его тип
-- *Demo> :t ($)
-- ($) :: (a -> b) -> a -> b
-- видим, Что это полиморфный тип
-- 1-й операнд функция (a -> b), 2-й операнд -> a - значение произвольного типа
-- 

-- Пример поинтереснее
-- в качестве аргументов функция - f , и некоторое значение  - x
-- f применяется к x (f x), получается некоторое значение
-- каков тип этого выражение (f x) ? тип - возвращаемое занчение ф-и f 
-- Допустип пусть f имеет тип a -> b , т.е. аргументом ф-и является тип - a , а тип возвращаемого значения - b
-- но теперь ф-я f еще раз применяется к результату применения  (f x), т.е. f (f x)
-- мы знаем, что аргументов ф-и f должен быть тип - a . Что же получается ? 
-- Это выражение на может быть типизировано ?
-- 
    aplay2 f x = f (f x)
-- да нет модуль загрузился и скомпилировался.
-- На самом деле возникает следующее : При выводе типов возникают уравнения на типы. 
-- Поскольку тип - a и тип - b совершенно произвольны, то то что происходит в применении выражения f (f x)
--  функции из  a -> b к значению типа - b , просто означает, что тип - a и - b это один и тот же тип
-- это одно и тоже , т.е. конструкция мономорфизируется.  Такое применение f (f x) , возможно только
-- если - a и - b это одно и тоже.
-- И действительно - если посмотрим на тип ф-и applay2 , то видим, что так оно и есть
-- 1-й аргумент - ф-я у которой аргумент и результат имеют один и тот же тип (t -> t)
-- 2-й аргумент значение того же самого типа -> t
-- И возвращаемым значением служит значение того же типа -> t
-- Demo> :t aplay2
-- aplay2 :: (t -> t) -> t -> t
-- и значит applay2 мы можем применять на более ограниченном наборе ф-й нежели чем ф-я $
-- $ - полиморфен по аргументу и повозвращяемому значению
-- Demo> :t ($)
-- ($) :: (a -> b) -> a -> b
-- то applay2 полиморфен только по параметру - t, который и аргумент и возвращаемое значение.
-- вот так можно применить эту ф-ю  aplay2 :
-- *Demo> aplay2 (+ 1) 2
-- 4
-- applay2 +1 2 = +1 ( +1 2) = +1 3 = 4
-- *Demo> aplay2 (+ (-1)) 2
-- 0
-- aplay2 + (-1) = + (-1) (-1 2) = + (-1) 1 = -1 + 1 = 0

-- Или вот так
-- Demo> aplay2 (++ "AB") "CD"
-- "CDABAB"

-- Теперь посмотрим на более полезную функцию
-- Это ф-я из стандартной библиотеки - flip
-- Она определена так : 
-- flip f y x = f x y
-- ей передаются 3 параметра.  некая ф-я f и два неких значения y, x
-- и потом ф-я f вызывается на параметьрах x, y в обратном порядке.
-- т.е. получается , что ф-я flip f , Просто переставляет местами 
-- параметры функции f x,y 
-- *Demo> flip (/) 4 2
-- 0.5
-- т.е. разделилось 2 на 4
-- или вот еще
-- *Demo> flip const 2 True
-- True