-- в Haskell как и в математика ф-я обычно именована.
-- Однико есть и анонимные лямбда функции
-- Пример :
--- 2 * x * 7 
-- оно содержит неизвестно - x . поэтому не может использоваться как замкнутое выражение.
-- обычно мы поступаем так :
-- let f x = 2 * x + 7
-- теперь это полноценная функция.
-- Существует альтернативный подход . Мы можем связать переменную - x , но не с помощью именованной ф-и
-- а с помощью лямбда выражения.
-- \x -> 2 * x + 7  это такая же ф-я как f x , но только она не имеет имени.
-- Main> (\x -> 2 * x +7) 10
-- 27
-- можно опреджелить ф-ю f с помощью этого лямбда выражения
-- let f = \x -> 2 * x + 7
-- как быть в случае ф-и 2-х аргументов.
-- *Main> let lenVec x y = sqrt $ x^2 + y^2
-- *Main> lenVec 2 3
-- 3.605551275463989
-- Main> let lenVec x = \y -> sqrt $ x^2 + y^2
-- *Main> lenVec 4 5
-- 6.4031242374328485
-- *Main> let lenVec  = \x -> \y -> sqrt $ x^2 + y^2
-- *Main> lenVec 4 5
-- 6.4031242374328485
-- существует синтаксический сахар - упрощения записи
-- *Main> let lenVec  = \x y -> sqrt $ x^2 + y^2
-- *Main> lenVec 4 5
-- 6.4031242374328485
-- Где же применяются лямбда-функции ?
-- Обычно в случае ФВП
-- можно и через where, но лямбда - лаконичнее.
-- Пример :  Есть две пары пары пар. и мы хотим суммировать первые элементы первых пар
-- Main> let p1 = ((1, 2), (3, 4))
-- *Main> let p2 = ((3, 4), (5, 6))
-- *Main> fst $ fst p1
-- 1
-- теперь на основе этого можно написать интересующую нас ф-ю
-- будем использовать оператор on
-- 
-- как вариант вот так через where
import Data.Function

sumFstFst = (+) `on` helper where
    helper pp = fst $ fst pp

-- *Main> let p1 = ((1, 2), (3, 4))
-- *Main> let p2 = ((3, 4), (5, 6))
-- *Main> sumFstFst p1 p2
-- 4
-- но мы хотим использовать лямбда.
sumFstFst' = (+) `on` (\pp -> fst $ fst pp)

-- *Main> let p1 = ((1, 2), (3, 4))
-- *Main> let p2 = ((3, 4), (5, 6))
-- *Main> sumFstFst' p1 p2
-- 4

