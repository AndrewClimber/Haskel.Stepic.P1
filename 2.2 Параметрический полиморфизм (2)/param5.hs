-- Пуская есть 2 полиморфные функции - f и - g
-- надо описать оператор композиции этих функций.
-- т.е. такую ф-ю, которая принимает f и g , а возвращает ф-ю , которая выполняет 
-- следующее действие :
-- она берет аргумент , применяет ф-ю - g  к этому аргументу, а потом к результату этого применения применяет ф-ю - f
-- Посомтрим со стороны типов как может выглядеть такой оператор композиции
-- Допустим есть некие ф-и f , g
-- f :: b -> c 
-- g :: a -> b (именно так. возвращаемое значение должно быть с типом - b , т.к. потом надо будет применить ф-ю f)
-- и чтобы что-то применять у нас должно быть значение  к которому будеи применять
-- ф-ю g . Это значение - x :: a , которое имеет тип - a
-- Давайте посмотрим на последовательное применение
-- Т.к. - g мы применяем к аргументу - x , то видим что аргумент по типу подходит для - g
-- и примененное -  g . (g x) - будет иметь тип - b
-- теперь к этому применению мы можем применить ф-ю - f . f (g x) . И это выражение f (g x) :: c . будет иметь тип - c
-- Но нам хочется получить функцию из - a . в - c . Как нам сделать из этого выражения функцию (оператор композиции) ?
-- Выражение имеет тип c - f (g x) :: c . И соответственно если мы абстрагируемся по иксу.
-- и напишем лямбда выражение  - \x -> f (g x) :: a -> c  - т.е. это выражение будетиметь тип из - a,  в - c
-- т.е. мы получили выражение, которое описывает композицию функций - f и g.
-- осталось только передать сюда функции - f и - g , т.е. написать следующую ф-ю :
-- let compose f g = \x -> f (g x) и посмотрим какой у нее тип.
-- Prelude> :t compose
-- compose :: (t1 -> t2) -> (t3 -> t1) -> t3 -> t2
-- соотнесение типов : t - c , b - t1 , a - t2
-- (t1 -> t2) - f , (t3 -> t1) - g 
--  В Haskell есть такой оператор композиции - точка . - оператор композиции функций.
-- Prelude> :i (.)
-- (.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in `GHC.Base'
-- infixr 9 .
-- Примеры :

import Data.Function

sumFstFst = (+) `on` helper where
    helper pp = fst $ fst pp

-- 
sumFstFst' = (+) `on` (\pp -> fst $ fst pp)    

-- вариант с использованием композиции
-- композиция передает аргумент в первую fst (самая правая), 
-- результат передается в другую fst (левая) и возвращается результат
sumFstFst' = (+) `on` (fst . fst)    

-- цепочка последовательных применений может быть заменена композицией.
{-
doIt x = f ( g (h x)) = f ((g . h) x) = (f . (g . h)) x
а потом поскольку x и справа и слева представляет собой последний аргумент
то можем перейти к бесточечному стилю - сократив x
doIt = f . g . h

Подобные преобразования используются часто. Тем более что они могут привести к более эффективной программе.
-}