import Data.Function
-- в Haskell синтаксис вызова ф-и отличается от императивных языков программирования
-- Мы пишем имя функции, А затем перечисляем аргументы : func x y z
-- и мы можем перечислить не все аргументы, А только их часть. Указать несколько первых. А остальные отбросить
-- Это идея частичного применения функции.
--  Когда само выражение представляет из себя функцию, в которую
-- могут быть переданы все оставшиеся аргументы - эта идея придумана Хаскелом Карри и такие функции называются
-- в честь него каррированными
-- в Haskell не все функции являются каррированными. Можем определять ф-и над картежами. 
-- В этом случае синтаксис вызова будет похож на синтаксис как в обычных языках func (3,'G')
-- Т.е. есть каррированные ф-и и некариррованные.
-- И стоит проблема как переходить от некаррированных к кариррованным и наоборот.
-- Пример : 
-- *Main> fst (1,2)
-- 1
-- Можем на нее глядеть - как ф-ю двух аргументов
-- переход от них к ф-ям - которые принимают аргументы по одному - называется каррированием.
-- В чем смысл каррирования ?
-- Допустип у нас есть ФВП. Например ф-я on
-- её тип 
-- *Main Data.Function> :t on
-- on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
-- первый параметр - ф-я 2х аргументов, которая не является каррированной (т.к. два аргумента)
-- т.е. вызвать ее передав в качестве 1-го параметра некарированную функцию - получим сообщение об ошибке.
{-
*Main Data.Function> :t fst `on` (^2)

<interactive>:1:1: error:
    * Occurs check: cannot construct the infinite type:
        b ~ (b -> c, b0)
      Expected type: b -> b -> c
        Actual type: (b -> c, b0) -> b -> c
    * In the first argument of `on', namely `fst'
      In the expression: fst `on` (^ 2)
*Main Data.Function>
-}
-- Сообщение об ошибке говорит, Что ожидается кариррованная ф-я , а fst  не является каррированной
-- fst принимает  пару (a, b) -> a
-- как осуществить переход от одной ф-и к другой ?
-- В Haskell - есть специальный комбинатор curry , который может это сделать. каррировать
-- *Main Data.Function> :t curry fst `on` (^2)
-- curry fst `on` (^2) :: Num c => c -> c -> c
-- превратит в стандартную каррированную ф-ю 2-х аргументов.
-- еще пример
-- эта ф-я некаррированная . и для применения в ФВП - ее надо каррироватьЖ
avg :: (Double, Double) -> Double
avg p = (fst p + snd p) / 2
-- *Main> :t avg
-- avg :: (Double, Double) -> Double
-- *Main> :t curry avg `on` (^2)
-- curry avg `on` (^2) :: Double -> Double -> Double

cavg = curry avg `on` (^2)
-- *Main> cavg 1 2
-- 2.5

-- как устроена ф-я curry ?
-- попробуем её сконструировать
-- curry - принимает некую функцию, заданную над парой некаррированную. и два аргумента, которые хотим использовать
-- curry f x y , причем x и y надо передать в f
-- let cur f x y = f (x, y)
-- *Main> :t curry
-- curry :: ((a, b) -> c) -> a -> b -> c
-- *Main> :t cur
-- cur :: ((a, b) -> t) -> a -> b -> t
-- т.е. она принимает неекаррированную ф-ю над парой ((a, b) -> t) 
-- а возвращает уже каррированную ф-ю  a -> b -> t . ф-ю в которой аргументы передаются последжовательно

-- есть и обратная ф-я - uncurry
-- *Main> :t uncurry
-- uncurry :: (a -> b -> c) -> (a, b) -> c


{-
В модуле Data.Tuple стандартной библиотеки определена функция swap :: (a,b) -> (b,a), переставляющая местами элементы пары:

GHCi> swap (1,'A')
('A',1)
Эта функция может быть выражена в виде:

swap = f (g h)
где f, g и h — некоторые идентификаторы из следующего набора:

curry uncurry flip (,) const
Укажите через запятую подходящую тройку f,g,h.
-}
swap' = f (g h) where
    f = uncurry
    g = flip
    h = (,)

    
-- *Main> uncurry (flip (,)) (1,2)
-- (2,1)

-- хотя можно было сделать и вот так
swp (x,y) = flip (,) x y    


{-
Сколько разных всегда завершающихся функций с типом a -> (a,b) -> a -> (b,a,a) можно реализовать?

a -> (a, b) -> a -> (b, a, a)

Перепишем как :
a1 -> (a2, b) -> a3 -> (b, an, ak)
a1 -> (a2, b) -> a3 = Fnk
Fnk= an ak  .  b отбрасываем,  т.к. не участвует в расчетах
n*k = результат
остается найти n и k
n = 3, k = 3,  n*k = 9

-}