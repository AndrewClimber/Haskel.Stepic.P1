-- ф-я полиморфна если она может запускаться на произвольном типе данных
-- Сейчас будем говорить про специальный полиморфизм
-- Он устроен по другому . Ф-я по прежнему может вызываться на различных типах данных. 
-- Но каждый тип данных должен быть обеспечен реализацией соответствующего интерфейса для
-- того чтобы ф-я могла его вызвать. Этот интерфейс в Haskell называется классом типов.
-- И класс типов описывает интерфейс целиком. И есть еще одно понятие - реализация классов типов.
-- Реализация представителя. Тип данных должен объявлять представителя  класса типов, т.е. имплеиентировать
--  соответствующий интерфейс. И после того как имплементировал соответствующий интерфейс - мы можем в специальную
-- полиморфную ф-ю такой тип данных передавать. Интерфейсы , о которых говорилось классов типов - они именованы
-- Давайте сначала посмотрим как в типе функций отражается наличие этих самых интерфейсов. 
-- Как мы помним числовые константы имеют полиморфный тип 
-- *Main Data.List> :t 7
-- 7 :: Num a => a
-- Мы видим, что 7  - имеет сложно устроенный тип. Давайте поймем как он устроен :
-- Если в типе обнаруживаем символ => , то этот символ следования разделяет тип на две части
-- правая часть - это тип выражения. Говорим , что 7 - имеет тип - a
-- А то что стоит слева от =>.  Num a - это ,так называемый, контекст. 
-- Контекст состоит из 2-х частей. 1-е это имя интерфейса, который должен выставлять тип, который используется
-- в правой части . И дальше указывается к какому типу применен этот интерфейс. В данном случае к - a
-- Т.е. получается, что 7 имеет полиморфный тип - a . Но для этого типа - a , должен быть выставлен интерфейс - Num.
-- Интерфейс Num выставляет целый ряд функций. Это числовой интерфейс. Числовой класс типов. Там имеются ф-и 
-- сложения, умножения, вычитания. Если посмотрим на тип оператора сложения
-- *Main Data.List> :t (+)
-- (+) :: Num a => a -> a -> a
-- Видим, Что тут присутствует специальный полиморфизм. Оператор сложения определен так :
-- Это ф-я , которая принимает 2 одинаковых по типу аргумента a -> a и возвращает значение того же типа -> a
-- На этот тип применен интерфейс Num  это означает, что на тот тип в контекста наложено ограничение 
-- этот тип - a должен относится , должен реализовывать интерфейс Num .
-- Есть и другие интерфейсы кроме Num .
-- *Main Data.List> :t (==)
-- (==) :: Eq a => a -> a -> Bool
-- Этот оператор принимает 2 аргумента одинакового типа и возвращает булево значение - Bool
-- Но на аргументы наложено ограничение - контекст Ord a означает, что тип a, который используется справа
-- должен быть представителем класса типов Ord
-- 
-- Попробуем что-то посложнее. Сечение оператора больше числом 7
-- *Main Data.List> :t (>)7
-- (>)7 :: (Ord a, Num a) => a -> Bool
-- (>)7 - это унарный предикат и он будет иметь тип a -> Bool , но контекст становится более сложным
-- На единственный аргумент, который передаем в оператор сравнения , на тип - a наложено два ограничения
-- Ord и Num , т.е. тип a , должен быть представителем классов типов Ord и Num. a должен быть представителем чисел.
-- И с ним могли бы проводиться логические операции сравнения.
-- Контексты Ord a и Num a - это разные контексты. Например комплексные числа являются представителями класса Num,
-- но не являются представителями класса Ord. 
-- Еще более сложный пример 
-- *Main Data.List> :t (>(1,2))
-- (>(1,2)) :: (Ord a, Ord b, Num a, Num b) => (a, b) -> Bool
-- Пары в кортеже сравниваются лексиграфически . Числа могут относиться к разным типам Int Double
-- В этом выражении мы не ограничили полиморфизм. Не указали явно тип. То видим, что первый тип пары -
-- полиморфный тип - a , второй тип пары - полиморфный тип b
-- и на оба этих типа наложены ограничения контекста и - a и - b должны иметь тип Num .
-- и оба иметь ограниченя Ord, т.к. мы должны уметь их сравнивать
-- Все это может нам помочь читать сооющения об ошибках. Допустим умышленную ошибку
-- *Main Data.List> :t (* 'c')
--
-- <interactive>:1:2: error:
-- * No instance for (Num Char) arising from a use of `*'
-- * In the expression: (* 'c')
-- Выражение не может быть типизировано. Ошибка говорит о том, что 'c' не является представителем
-- класса типов Num - No instance for (Num Char)
-- Нет реализации представителя типа Char, так чтобы он относился к классу Num.
-- Т.е. мы сконструировали выражение, которое неправильно типизировано.

{-
Попробуйте, не используя GHCi, определить, какого контекста не хватает для того, 
чтобы выражение

x :: ?? => Bool
x = True + False * False
могло бы быть типизировано.

Ответ : Num Bool
-}
