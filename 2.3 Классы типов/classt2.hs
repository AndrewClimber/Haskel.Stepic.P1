-- Класс типов задает интерфейс, который конкретные типы могут реализовывать.
-- Сам по себе класс типов представляет собой именованный набор имен функций с сигнатурами
-- параметризованный общим типовым параметром 
-- Пример Как устроен класс типов:
-- 
module Demo where

-- Класс типов Eq . Eq - это имя классов типов
-- типовой параметр, который параметризует этот класс типов - a
-- Когда будем объявлять представителя этого класса типов вместо типового параметра - a
-- подставится конкретный тип, который будет выставлять соответствующий интерфейс
-- далее идет ключевое слово where
-- дальше идут перечисления сигнатур функций
-- В классе типов Eq - объявлено две функции
-- (==) - ф-я сравнения элементов типа a -> a , она проверяет два элемента типа - a и возвращает значение типа Bool
-- Тут не задается реализация. А только интерфейс.
-- Реализация будет своя для каждого типа , который будет подставлен вместо типового параметра - a
-- Вторая ф-я (/=) - сравнение на неравенство. Сигнатура у нее точно такая же. Но семантика будет 
-- конечно другая - сравнение на неравенство.
    class Eq a where
        (==) :: a -> a -> Bool
        (/=) :: a -> a -> Bool
-- Посмотрим как класс типов Eq работает. Пример с Eq - взят из стандартной библиотеки.
-- *Main Data.List> :t (==)
-- (==) :: Eq a => a -> a -> Bool
-- Видим контекст, который указывает, что значения могут сравниваться на равенства только 
-- если - a принадлежит этому классу типов Eq, только если представитель этого класса типов реализован
-- Это же указание на контекст сохраняется Eq a , если наша ф-я остается полиморфной. Например если мы сделаем
-- сечение этого оператора числовым значением , поскольку числовое значение полиморфно, то мы сохраним 
-- контекст Eq a, но добавится контекст Num a, т.к. 42 - это число.
-- *Main Data.List> :t (== 42)
-- (== 42) :: (Eq a, Num a) => a -> Bool
-- Однако если полностью уберем полиморфизм , поставив сюда конкретный тип вместо значения - a, 
-- то контекст Eq - пропадет. Например какое-либо Char. Контекст Eq - был использован при выводе типов
-- поскольку тип Char - является представителем классов типов Eq , то такое выражение (== 'x') является
-- правильным выражением языка и соответственно тип выводится 
{- Я правильно понимаю разницу между (==42) и (=='x') - первое относится к Num т.е. может быть Int, Double 
возможно ещё чем-то. второе жестко связано с Char т.к. ничем другим быть не может плюс Char реализует интерфейс 
Eq и в итоге такой тип? 
Ответ : Да
}
-- *Main Data.List> :t (== 'x')
-- (== 'x') :: Char -> Bool
-- Посмотрим на тип некоторых ф-й, которые используют контекст Eq 
-- Например elem
-- *Main Data.List> ::t elem . Проверяет - является ли некое значение элементом списка
-- elem :: (Foldable t, Eq a) => a -> t a -> Bool
{-
Применение тИповой переменной t (описывающей однопараметрический конструктор типа) к тИповой переменной a. 
На переменную t наложено ограничение, она должна принадлежать к классу типов Foldable. Конструктор списка 
удовлетворяет этому ограничению, поэтому допустимый, хотя и не наиболее общий тип таков 
elem :: Eq a => a -> [] a -> Bool, или в более традиционной миксфиксной нотации elem :: Eq a => a -> [a] -> Bool . 
}

{-
Попробуйте, не используя GHCi или Hoogle, определить, какого контекста не хватает в типе функции

sort :: ? => [d] -> [d]
сортирующей переданный в нее список. Напишите выражение, которое должно стоять на месте знака вопроса.

Ответ : Ord d
}

