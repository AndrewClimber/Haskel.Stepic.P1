-- Конкретный тип называется представителем класса типов, Если для него реализованы все функции, которые
-- в классе типов объявлены.
-- Иногда вместо слова представитель используют слово экземпляр (instance)
-- Как же можно реализовывать экземпляры классов типов :
module Demo where
    class Eq a where -- это класс тип
        (==), (/=) :: a -> a -> Bool -- два оператора(ф-и) .Если сигнатура ф-й одинакова, то ф-и можно перечислить
                                     -- через запятую, а потом записать их сигнатуру
-- теперь хотим сделать конкретный тип претставителя (instance) Eq
-- подставив конкретный тип.
instance Eq Bool where -- за ключевым словом instance идет имя классов типов, экземпляр, 
-- которого реализуем, потом идет конкретный тип для которого реализуем этот экземпляр  
-- он подставляется вместо типового параметра в класс типе  class Eq a - вместо a
-- таким образом наша ф-я приобретает сигнатуру Bool -> Bool -> Bool
-- после этого ф-ю Bool -> Bool -> Bool - надо реализовать
    True == True   = True  -- Это первая ф-я она реализует сигнатуру равенства. Она определена с помощью сопоставления
    False == False = False -- с образцом. Для сокращения не писали пары True == False и False == True
    _     == _     = False -- а использован спец-символ _ - который означает во всех остальных случаях
-- далее реализация второго оператора - неравенства. Эта ф-я реализована через первую ф-ю
    x /= y = not (x == y)
-- В Haskell реализация интерфейса и объявление типов данных разнесена.

-- Еще один иснтрумент, связанный с классами типов . Это - методы по умолчанию.
-- реализация x /= y = not (x == y) - подходит для любого представителя. Хоть Bool, хоть Int
-- т.е. она полиморфна. И Haskell позволяет сделать реализацию по умолчанию - в непосредственном объявлении
-- классов типов. Т.е. вот так :
class Eq a where 
        (==), (/=) :: a -> a -> Bool
        x /= y = not (x == y)

instance Eq Bool where
    True == True   = True  
    False == False = False 
    _     == _     = False

-- И теперь в Eq можно реализовывать не все методы, а только те, которые не имеют реализацию по умолчанию
-- Когда мы реализуем представителя классов типов, то мы можем перекрывать реализацию метода по умолчанию
-- А еще можно давать циклические реализации по умолчанию.
class Eq a where 
    (==), (/=) :: a -> a -> Bool
    x /= y = not (x == y)
    x == y = not (x /= y)
-- minimal complete definition - минимальное полное определение , это что в классе типов надо реализовать
-- а что реализовано методами по умолчанию.
-- может получится так - что для всех методов есть реализация по умолчанию 
-- тогда можем просто писать : instance , имя классов типов, имя типа, where - и более ничего
-- Надо быть осторожным. Т.к. если циклично, то что-то реализовать надо. Чтобы подхватилось
-- а если не циклично - то не надо реализовывать.
    