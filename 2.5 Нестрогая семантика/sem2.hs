{-
Какими св-вами обладает ленивая модель по сравнению с более трпдиционной энергичной
-}
add7 :: Int -> Int -> Int
add7 x y = x + 7

{-
как происходит редукция в 2-х моделях вычисления
ленивая модель . 
add7 1 (2 + 3)
~> 1 + 7
~> 8

энергичная модель
add7 1 (2 + 3)
~> add7 1 5
~> 1 + 7
~> 8
В данном примере ленивая стратегия эффективнее энергичной. но так бывает не всегда.
-}
dup :: Int -> (Int, Int)
dup x = (x, x)
{-
ленивая модель . 
dup (2 + 3)
~> (2+3, 2+3)
~> (5, 2+3)
~> (5, 5)

энергичная модель
dup (2 + 3)
~> dup( 5 )
~> (5, 5)

В данном случае ленивая стратегия проигрывает
Можно сформулировать правило : Если у нас какие-то параметры в правой части игнорируются. Как в первом случае,
тогда ленивая стратегия имеет преимущество. Если же параметр используется несколько раз, то преимущество имеет
энергичная стратегия.

Но придуман механизм, который позволяет в ситуации, когде в правой части переменные используются несколько раз,
считать ее один раз. Это механизм разделения. Вместо того чтобы осуществлять чисто синтаксическую подстановку
при вызове функции - добавляется дополнительный уровень косвенности. И подставляется не выражение 2+3,
а некий указатель - (p, p) он указывает на область памяти - где может храниться отложенное вычисление, а может
храниться значение p => 2+3 и когда приходит время вычислять - оно выполняется и p => 5 и указатель указывает
на значение.
dup (2 + 3)
~> (p, p)   p => 2 +3
~> (5, p)  p => 5
~> (5, 5)
-}
