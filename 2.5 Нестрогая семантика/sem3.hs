{-
М-м ленивых вычислений может приводить к интересным эффектам
Программы - которые могут незавершаться - с помощью ленивых вычислений 
можно элиминировать эту незавершаемость. И таким образом улучшить код.
-}
module Demo where

const42 :: a -> Int
const42 = const 42
{-
*Demo> const42 True
42

*Demo> const42 (12332+3293457+3094834958+0328309485)
42
вычисление никогде не произойдет.
Т.е. на вход const42 - можем передавать любую . Даже незавершающуюся программу.
*Demo> const42 undefined
42
undefined - прерывает выполнение программы.
Но она не вызывается.
Мы можем элиминировать расходимости.

Мы называем выражение расходящимся, если вычисление его значения приводит к бесконечному циклу 
или аварийному завершению.

ф-и подобные const42 - называются нестрогими функциями.
Формально нестрогая ф-я определяется вот так :
Если в  ф-ю передано расходящееся вычисление, а результатом является нерасходящееся значение. То
такая ф-я называется нестрогой.
Алтернативным термином служит - строгая ф-я. Если в функуию передаем расходящийся аргумент - результат будет 
расходящимся.
-}


foo a = a

bar = const foo
{-
(const foo) 1 2
никак не могу понять, почему возвращается 2

(const foo) 1 2 = ((\x y -> x) foo) 1 2 = (\y -> foo) 1 2 = foo 2 = 2
-}

--bar' x y = const foo

baz x = const True

quux = let x = x in x

corge = "Sorry, my value was changed"

grault x 0 = x
grault x y = x

garply = grault 'q'

waldo = foo
