{-
Вычисление в функциональных языках - это процесс редукции.
Редукция происходит до тех пор - пока внутри выражения сохраняютсе редексы.
И в конце получается выражение - которое редексов не содержит.
Про такие выражения говорят, что они находятся в нормальной форме.
Т.е. оно дошло до окончательного результата и в нем никаких вычислений провести нельзя.
В Haskell есть понятие - слабой головной нормальной формы. Weak head normal form ( WHNF )
3 примера выражений, которые находятся в нормальной форме NF :

42 - просто число . никаких дальнейших вычислений провести невозможно
(3,4) - конструктор пары - примененный к двум значениям
Однако NF - это не только, когда имеется какое-то конечное значение. Ф-и тоже могут находиться в NF
\x -> x + 2 - лямбда-функция. в которой тоже невозможно провести вычисления. Нет редексов, которые можно
было бы вычислить. + эт овстроенный оператор - его можно вычислиьб, когда вычесленны все его аргументы.

Примеры выражений, которые не находятся в NF :

"Real" ++ "world"  ++ может быть применен. можно провести подстановку определения оператора ++ . т.е. имеэтся редексы
sin (pi / 2) - два редекса
(\x -> x + 2) 5 - ф-я находится в NF, но примененная к 5
(3, 1 + 5) - конструктор пары примененный к значению и к редексу

Что такое WHNF ?
Это выражение - которое находится в одном из трех следующих видах :
1.Любая лямбда-абстракция \x -> x + 2*3  - редоекс находится за пределом лямбда-абстракции. Т.е. внутри лямбда-функции
2.Конструктор данных (3, 1+5) - редекс за барьером конструктора
3.Конструктор данных может быть частично применен (,) (4*5) - редекс за барьерос конструктора данных
4.Частично примененная встроенная функция (+) (7^2) - редекс за барьером встроенной функции. Есчли бы вместо (+)
была ,написанная мной функция myFunc (7^2),  то это выражение не было бы WHNF

Выражения, которые находятся в NF - автоматически находятся и в WHNF
вычисления Haskell зачастую останавливаются на WHNF и не доходят до NF
-}