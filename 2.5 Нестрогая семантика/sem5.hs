{-
Ленивая семантика значит, что если какое-то выражение не требуется - для получения результата,
то это выражение никогда не будет редуцироваться. Однако, иногда это приводит к проблемам.
Имеется м-м отложенных вычислений. И когда обрабатываем огромные массивы данных . Списка бесконечной длины -
может возникнуть ситуация , когда отложенные вычисления накапливаются . Например, хотим проссумировать элементы
такого списка - и тогда может накопиться длинное вычисление - и когда завершаем этот список -
это вычисление будет произведено , но это вычисление может занимать большое место в памяти
10-ки миллионов элементов. 10-ки миллионов чисел в памяти связанные оператором сложения - готовые к сложению
Но не можем их сложить - из-за модели вычисления.  Утечки памяти - это проблема у Haskell.
Есть способы сообщить компилятору сделать это накопленной длинное вычисление.
Оператор - seq . Это вычислительный примитив. Он нарушает ленивую семантику Haskell. Когда используется 
seq - вычисления перестают быть ленивыми. 

Prelude> :t seq
seq :: a -> b -> b - определен как ф-я 2-х аргументов
и возвращает значение своего 2-го аргумента. Ведет себя почти как ф-я const,
только const возвращяет 1-й аргумент
Prelude> const 1 3
1
Prelude> seq 1 3
3
ф-я seq - эквивалентна конструкции : flip const
Prelude> flip const 1 3
3

seq _|_ b = _|_
_|_ - называется основание. И обозначает расходящееся вычисление
это значит, что если первый аргумент ф-и seq - расходится - то seq  расходиться.
seq a b = b - а если 1-й аргумент вычисляется до значения - то просто взвращает второй аргумент,
игнорирую первый.
seq - форсирует вычисления своего первого аргумента.
и если он расходится _|_ - то seq расходиться. А если 1-й не расходится - то возвращается 2-й аргумент
Примеры использования seq :
Расходимости нет
Prelude> seq 1 2
2

Расходимость есть с аварийным завершением.
Prelude> seq undefined  2
*** Exception: Prelude.undefined

Некое вычисление. Тоже расходится
Prelude> seq (id undefined)  2
*** Exception: Prelude.undefined

Насколько глубоко seq форсирует вычисление своего 1-го аргумента ?
seq форсирует его не до NF, а до WHNF

Нерасходится в случае конструктора пары - WHNF . seq строит пару - а аргументами пары не интересуется.
Prelude> seq (undefined, undefined) 2
2

так же в случае с лямбда выражением. - WHNF . и seq дальше не форсирует вычисления.
Prelude> seq (\x -> undefined) 2
2

Итак - seq форсирует вычисления. но это не полное форсирование. А только до WHNF.
-}

{-
выражение   x' `seq` y' `seq` n' `seq` quux n' p        равносильно
выражению  x' `seq` (y' `seq` (n' `seq` quux n' p))   - так? 

-}
foo 0 x = x
foo n x = let x' = foo (n - 1) (x + 1)
          in x' `seq` x'

bar 0 f = f
bar x f = let f' = \a -> f (x + a)
              x' = x - 1
          in f' `seq` x' `seq` bar x' f'
          
baz 0 (x, y) = x + y
baz n (x, y) = let x' = x + 1
                   y' = y - 1
                   p  = (x', y')
                   n' = n - 1
               in p `seq` n' `seq` baz n' p

quux 0 (x, y) = x + y
quux n (x, y) = let x' = x + 1
                    y' = y - 1
                    p  = (x', y')
                    n' = n - 1
                in x' `seq` y' `seq` n' `seq` quux n' p

-- not foo 
-- bar ??
-- not baz
-- not quux