{-
ф-я seq не очень удобна.
поэтому определен оператор аппликации с вызовом по значению.
который позволяет более удобно использовать форсированные вычисления.
*Main> :t ($!)
($!) :: (a -> b) -> a -> b
Похож на
*Main> :t ($)
($) :: (a -> b) -> a -> b

$! реализован следующим образом :
f $! x = x `seq` f x
x `seq` f x работает так : 
1. вычисляется до слабой заголовочной формы x
2. вычесленный на шаге 1 x - используется в аппликации ф-и f к своему аргументу
3. возвращяющим значением оператора seq служит его 2-й аргумент, т.е. возвращается значение f x
Ф-я f применяется к своему аргументу x, но при этом аргумент x - вычисляется до того как происходит
применение f к x


*Main> const 42 undefined
42
*Main> const 42 $ undefined
42
*Main> const 42 $! undefined
*** Exception: Prelude.undefined
$! - форсирование вычисления  приводит к уменьшению определенности
Выражение становится хуже определенным.
!$ - нужен для того, чтобы не накапливались отложенные вычисления.

Пример, где такие вычисления могут накопиться
-}
-- Например в вычислении факториала могут накопиться

factorial :: Integer -> Integer
factorial n | n >= 0 = helper 1 n
            | otherwise = error "arg must be >= 0"
    where
        helper acc 0 = acc
        --  в (acc * n) - накапливается цепочка произведений. неумножаясь. пока не дойдет до n = 1
        helper acc n = helper (acc * n) (n - 1)

factorial' :: Integer -> Integer
factorial' n | n >= 0 = helper 1 n
            | otherwise = error "arg must be >= 0"
    where
        helper acc 0 = acc
        --  внесем изменения со строгим операторм применения.
        -- т.к. $! имеет низкий приоритет, то понадобятся еще одни скобки.
        -- в этой версии цепочка не накапливается. а вычисляется на каждом шаге.
        -- т.е. (acc  * n) будет каждый раз вычисляться прежде чем передасться в helper
        helper acc n = (helper $! (acc * n)) (n - 1)        

-------------------------------------------------------------------------------------------------
mySum acc 0 = acc
mySum (result, ()) n = (mySum $! (result + n, ())) $ n - 1
        
goSum = mySum (0, ())


