{-
Тема
1. Ленивость и строгость
2. Алгебраические типы данных. Сопоставление с образцом
3. Списики и работа с ними.

Сколько знвчение в типе Bool ?
Bool = True | false
Вроде бы два

-}

bot = not bot -- рекурсивное определение. вычисляться будет вечно. _|_ . Расходится.
{-
В Haskell _|_ основание это значение разделяемое всеми типами.
-}

const42 x = 42 -- ф-я всегда игнорирует свой аргумент. и всегда возвращет 42

{-
*Main> const42 bot -- передали, в качестве аргумента, расходящуюся ф-ю bot
42
всегда возвращает 42. т.к. вычисления происходят по необходимости. 
передали в const42 - ф-ю bot , а она не используется. значит и не вычисляется.
Такие ф-и, как const42, игнорирующие значение своего аргумента, называются нестрогими по этому
аргументу.
Для строгих функций, наоборот, всегда выполняется :
f _|_ = _|_

В Haskell - Все ф-и рассматриваются, как ф-и одного аргумента, и именно 
относительно 1-го аргумента!!! говорим - строгая ф-я или нет. !!!! 
В ф-и с несколькими аргументами - там все сложнее.

Анализ строгости и нестрогости это в Haskell - очень важно. Поэтому надо понимать, Чт оопределение строгости - это
определение на одном аргументе. 
Поскольку в Haskell все ф-и чистые и поведение определяется значением аргумента, то для ф-и одного аргумента - мы
всегда можем четко сказать - как она себя ведет.

Для форсированного вычисления значения используют специальный комбинатор вида :
seq :: a -> b -> b
seq _|_ b = _|_
seq a b = b , если a <> _|_
С чисто синктаксической точки зрения seq это : \x y -> y.
Но seq "нарушает" ленивую семантику языка, позволяя форсировать вычисление без необходимости!

Форсируя вычисления - мы предотвращаем аккумулирование отложенных вычислений.
seq - не может быть написан на языке - т.к. он меняет семантику. это некое расширение языка.
seq - берет 1-й аргумент и вычисляет его и если в 1-й аргумент = _|_ , то результат = _|_
если 1-й аргумент <> _|_ , то 1-й аргумент вычисляется , но возвращается 2-й параметр.

seq a b , если a = _|_, то seq a b = _|_, если a <> _|_, то seq a b = b

Как сильно seq форсирует выражение ? До куда он проводит вычисления ?
seq помогает распространению  _|_ , вычисляя свой 1-й аргумент.
*Main> seq undefined 42
*** Exception: Prelude.undefined

*Main> seq (id undefined) 42
*** Exception: Prelude.undefined
В этом случае seq a b = _|_ при a = _|_ 


seq Форсирует вычисление не до конца !!! Точнее - он свой 1-й аргумент до конца не вычисляет.
Конструкторы данных и лямбда-абстракции, являясь "значениями" , обеспечивают барьер для
распространения _|_ . И тем самым предотвращяют вычисление 1-го аргумента до NF
Пример :
*Main> seq (undefined, undefined) 42
42

конструктор (,) - вычислился и на этом остановился. значения конструктора в оконечном вычислении
не использовались. и в результате на выходе - 42
В этом случае seq a b = b при a <> _|_ 

Аналогично и в этом примере, т.к. лямбда-абстракция также является барьером для дальнейших вычислений :
*Main> seq (\x -> undefined) 42
42
Вместо undefined может быть иное. Более сложное выражение
*Main> seq (sin 1234, pi*234) 42
42

Т.е. seq вычисляет не до конца. Есть ф-я deepseq - он вычисляет до NF (используется в параллельных вычислениях)


Помимо seq есть оператор энергичной аппликации $! с вызовом по значению.
*Main> :i ($!)
($!) :: (a -> b) -> a -> b      -- Defined in `GHC.Base'
infixr 0 $!

f $! x = x `seq` f x

f $! x - сначала вычисляется x (не до конца. до WHNF), а потом происходит аппликация f x

Поскольку оператор энергичной аппликации $! с вызовом по значению.
То вот так уже не пройдет

*Main> const42 $! undefined
*** Exception: Prelude.undefined

-}



