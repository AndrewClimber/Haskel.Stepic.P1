{-
Сопоставление с образцом использовали - для исследования списка - проникая во внутрь списка на несколько шагов.
Однако, существует более мощный метод, связанный с использованием рекурсии. Когда мы можем перебирать всеь список.
Пока он не закончится.
ранее использовали для сопоставления конструктор (:) - оно обладает следую щим свойством :
Оно при сопоставлении разбивает список на голову и на хвост. при этом мы отрываем голову от тела списка..
И при каждом шаге рекурсии - список становится короче. И терминирующим условием для рекурсии в этом случае
является []
-}
module Demo where

import Prelude hiding (length, (++), null) -- прячем ф-и, которые будем переопределять.

length :: [a] -> Int
length [] = 0
length (x:xs) = 1 + length xs -- length xs - это рекурсивный вызов ф-и length на хвосте списка. 
                              -- при таких вызовах список при каждом вызове уменьшается на 1
length' (_:xs) = 1 + length' xs  -- в правой части нат x. поэтому так
-- это стандартный паттерн рекурсии на списках

-- более сложный пример
-- 2-й аргумент. второй список ys - трогать не будем. перебираем 1-й аргумент xs
-- по 1-му аргументу пишем 2 уравнения.
(++) :: [a] -> [a] -> [a]
[] ++ ys = ys  -- в случае конкатенации с пустым списком - ничего делать не надо. только вернуть 2-й аргумент
-- если список не пустой . делаем сопоставление с образцом в 1-м аргументе.
-- рекурсивно вызываем ++ на хвосте 1-го списка и на 2-м списке - (xs ++ ys)
-- и к пуолучившемуся списку в голову - добавляем элемент x - x : xs ++ ys 
-- оператор ++ - будет вызываться до тех пор пока не опустеет. граничное уравнение в первом уравнении [] ++ ys = ys
(x:xs) ++ ys = x : xs ++ ys -- тут подразумеваются скобки - x : (xs ++ ys). 
-- но мы их не поставили, т.к. ++ и (:) имеют одинаковый приоритет и правую ассоциативность.

-- третий пример
null : [a] -> Bool
null [] = True
null _ = False

                              