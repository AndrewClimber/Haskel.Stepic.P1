{-
схема рекурсии из прошлого степа - самая простая и самая естественная для работы со списками.
Однако возможны и другие схемы обработки списков. Например в качестве терминирующего условия может
выступать не пустой список, а какая-либо иная ситуация.
Например строго одно-элиментный список.
-}
module Demo where

import Prelude hiding (last,init,reverse)

last :: [a] -> a
last (x:[]) = x  -- одноэлементный список. терминирующее условие. образец, говорит о том, что список должен быть составлен с помощью (:)
                 -- слева элемент - x, а справа не xs, а пустой список. 
                 -- Т.е. сопоставление с образцом происходит удачно, когда в списке ровно 1-н элемент. И в этом случае этот элемент и 
                 -- возвращаем = x
last (_:xs) = last xs  -- все остальные случаи разбираются в следующем уравнении. Элемент нас не интересует. Интересен только хвост списка :xs
                       -- 1й элемент отбрасывается _ .И ф-я last вызывается рекурсивно на хвосте списка. 
                       -- Таким образом все элементы кроме последнего отбрасываются. А последний эл-т возвращается  last (x:[]) = x

-- init - это tail наоборот.
init :: [a] -> [a]
init [] = error "This list is empty!" -- так можем обработать случай пустого списка на входе s
--init [x] = [] -- одноэлементный список если 2х или 3х элементный список , т овот так [x,y,z] = []
init [_] = [] -- или так т.е. отбрасываем этот элемент.
init (x:xs) = x : init xs -- Во всех остальных случаях - пересобираем список. 
                          -- вызываем init на хвосте списка. и добавляем в голову списка X
                          -- таким образом пока список содержит больше одного эл-та - используется данное уравнение
                          -- список просто пересобирается. А в случае, когда остается ровно один элемент - возвращяем пустой эл-т init [_] = []
                          -- и получаем список без последнего эл-та.
{-
last и init определены не всегда. На пустых списках они не работают.
-}

-- пример посложнее ф-я reverse . Надо одновременно удерживать и старый и новый список. В новый список складывать элементы в обратном порядке.
-- используем для этого вспомогательную ф-ю с аккумулирующим параметром.
reverse :: [a] -> [a]
reverse l = rev l [] where -- для ревреса списка l - надо вызвать ф-ю rev . Функцию 2-х аргументов . Это наш список - l и 
                           -- пустой список [], в котором будет накапливатся инвертированный список.
    rev [] a = a -- ф-я rev делает следующее - если исходный список пришел пустой, то она возвращает инвертированный список - a    
    rev (x:xs) a = rev xs (x:a) -- если исходный список не пустой, то тогда 1-е уравнение не работает. Срабатывает 2-е уравнение.
                                -- ф-я rev вызывает себя рекурсивно. При этом она берет от исходного списка хвост в качестве 1-го аргумента.
                                -- таким образом исходный список сокращается при рекурсивных вызовах. И в конце концов дойдет до пустого списка.
                                -- а второй аргумент наоборот нарастает. Изначално был список a (в самом начале []), то теперь в его голову
                                -- добавляется элемент - x , который отрывается от первого аргумента. 1-й список уменьшается 2-й нарастает.
                                --   