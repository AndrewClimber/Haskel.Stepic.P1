{-
Еще одна схема рекурсии возникает, когда есть ф-я - у которой есть несколько списочных аргументов.
Тогда надо делать сопоставление образцов с несколькими аргументами.
-}

import Prelude hiding (zip, zip3, unzip)

zip :: [a] -> [b] -> [(a,b)] -- принимает два списка, соединяет их поэлементно и возвращает пару упакованную в результирующий список
{-
*Main> zip [1,2,3] ["qwe","dgdfg","ssdf"]
[(1,"qwe"),(2,"dgdfg"),(3,"ssdf")]
Или вот так
*Main> zip [1,2,3] "Hello"
[(1,'H'),(2,'e'),(3,'l')]
-}
zip []     _      = [] -- первый случай, когда первый
zip _     []     = [] -- или второй список пустые. В обоих случаях - релультатом является пустой список
zip (a:as) (b:bs) = (a,b) : zip as bs -- когда списки не пустые. Используем стандартное сопоставление с образцом
-- разбивая оба списка на хвост и голову (a:as) и (b:bs) . Далее берем голову первого списка и голову второго списка 
-- и соединяем их в пару (a,b), а над хвостами as и bs рекурсивно вызываем ф-ю zip . Длины списков уменьшаются на единицу на каждом шаге.
-- И когда один из списков обнуляется - то работа функции завершается.
{- можно обобщить ф-ю zip, рассмотрев ф-ю zip3
-}
zip3 :: [a] -> [b] -> [c] -> [(a,b,c)] -- тоже, что и zip, но с 3-мя списками.
zip3 (a:as) (b:bs) (c:cs) = (a,b,c) : zip3 as bs cs -- разбивает каждый из списков на голову и хвост. составляет из голов тройку. А на хвостах рекурсия.
                                                    -- и  тройка (a,b,c) добавляется в голову результирующего списка.
zip3 _      _      _      = [] -- во всех остальных случаях, когда один из списков пуст, т.к. все непустые случаи покрвываются в предыдущем
-- уравнении. zip3 (a:as) (b:bs) (c:cs) . Возвращается []

--операция обратная к zip - операция unzip
unzip :: [(a,b)] -> ([a],[b]) -- берет список пар и возвращает пару списков, где первый список состоит из первых элементов пары
                              -- а второй список из вторых элементов пары. 
unzip [] = ([],[])  --  если пустой список, то возвращает пару пустых списков.
unzip ((x,y):xys) = -- если списко непустой, то взяли хвост xys и голову, которая представляет собой пару (x,y)
                    -- и идет более глубокое сопоставление с образцом. x связывается с 1-м элементом пары, у со 2-м элементом текущей пары.
                    -- ну а xes - это хвост, который представляет собой список пар     
    let (xs,ys) = unzip xys -- рекурсия unzip на хвосте
    in (x:xs, y:ys) -- тут добавление значения x в голову, а значения у в хвост . А хвост берем вот так unzip xys см. строчку выше.
    -- разбор результата происходит с помощью конструкции let in . Вызываем рекурсивно на хвосте unxip xys. let (xs,ys) = unzip xys
    --  unzip xys - возвращает пару списков ([a],[b]). Сопоставление с образцом происходит в let (xs,ys) в let разбираем возвращаемую
    -- пару списков , первый список - значения типа a, второй типа b
    -- есть все 4-ре компонента две головы и два хваоста. После этого элемент x типа a добавляем к списку xs типа [a]
    -- и элемент y типа b к списку ys типа [b] in (x:xs, y:ys)
