{-
Функции для работы со списками. Продолжение.
Ф-и с аргументами. Часть из которых списочные, а часть не списочные.
Рассмотрим как сопоставление с образцом поможет писать такие функции.
-}
module Demo where

import Prelude hiding (take, drop, splitAt, (!!))

take :: Int -> [a] ->[a] -- возвращает список из n первых элементов исходного списка.s
-- сопоставление образцов.
-- первые два выражения - это терминирующие условия
take n _  | n <= 0 = [] -- тут просто связывание переменных. Связывается n с числом . И _ - игнорируется список
take _ [] = [] -- И тут тоже просто связывание переменных. Только игнорируется число n . 
               -- Какое бы оно не было - если список пуст на входе, то он пуст и на выходе. 
take n (x:xs) = x : take (n - 1) xs -- 3-е уравнение, которое содержит рекурсивный вызов. Тут говорится, что если список не пустой
-- и число n > 0 , то мы вызываем рекурсивно ф-ю take на хвосте списка xs, передавая в качестве аргуммента числа n-1
-- при этом в голову списка добалвяется элемент x, который является текущим элементом списка.
-- Т.е. рекурсия происходит следующим образом : У нас с каждым шагом уменьшается число n-1 и сокращается на один элемент длина списка xs
-- если у нас раньше кончиться список , то будет использоваться вот это терминирующее условие рекурсии : take _ []
-- а если раньше кончится число, т.е. станет n <= 0, то сработает вот это терминирующее условие : take n _
-- и в любом случае в качестве базы будет пустой список , а в новый список добавятся элементы x в количестве n-1 , 
-- либо в меньшем количестве если список короче length xs < n

drop :: Int -> [a] -> [a] -- по сигнатуре идентична take. Однако поступает ровно наоборот.
-- она пропускает n элементов списка xs, а оставшийся хвост возвращает. 
-- take - возвращает n-первых элемента. drop отбрасывает n-первых элемента.
drop n xs | n <= 0 = xs
drop _ [] = []
drop n (_:xs) = drop (n-1) xs -- рекурсия на хвосте, список уменьшается , но в отличие от take ничего не добавляется
-- нет операции x : . Т.е. n-первых элемента отбрасываются. А дальше натыкаемся на терминирующее условие 
-- если кончился список drop _ [] , а если кончилось число, то срабатывает терминирующее условие  n xs | n <= 0

-- эта ф-я объединяет идей функция take и drop
-- splitAt принимает целое число и список . Разрезает список на два списка  , которые возвращает
-- в виде пар. Первый список результат ф-и take, второй результат ф-и drop
-- т.е. разбивает список на два подсписка по позиции, которая переданна с помощию целого числа.
splitAt :: Int -> [a] -> ([a], [a])
splitAt n xs = (take n xs, drop n xs)

-- последний пример это оператор обращения по индекус к элементу списка. Счет идет от нуля.
xs !! n | n < 0 = error "Prelude.!!: negative index"
[] !! _         = error "Prelude.!!: index too large"
(x:_) !! 0      = x
(_:xs) !! n     = xs !! (n - 1) -- список разбирается. надо вернуть ровно один элемент. поэтому 1-й отбрасывается _
-- вызывается рекурсивно оператор !! на хвосте списка. xs !!, т.е. сдвигаемся по списку вправо  и одновременно уменьшается индекс (n - 1)
-- если список кончится раньше, то сработает [] !! _ 
-- если n станет == 0 , то Ура! мы нашли элемент списка, который соответствует индексу - (x:_) !! 0      = x
-- если раньше кончится число то сработет терминатор -  xs !! n | n < 0

