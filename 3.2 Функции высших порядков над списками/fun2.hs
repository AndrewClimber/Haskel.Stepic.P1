{-
При работе с контейнерами часто возникает ситуация, когда надо каждый его элемент 
обработать какой-то функцией и поместить результат в голову другого контейнера. 
При этом структура контейнера, порядок и кол-во элементов не меняются. А вот тип измениться может.
В Haskell есть ФВП, которая может сделать такую работу. Это - ф-я map
В качестве 1-го аргумента она принимает производную ф-ю, а в качестве 2-го аргумента - список.
-}
module Demo where

import Prelude hiding (map, concat, concatMap)

map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
{-
*Main> map (+10) [1,2,3,4,5]
[11,12,13,14,15]

*Main> map (\x -> (cos x / sin x)^2) [1,2,3,4,5]
[0.412282927437392,0.20945043706303793,49.213768360408736,0.7459624102762391,8.750528099598323e-2]

*Main> map length ["asd","sd;lsdflds", "sd"]
[3,10,2]
-}

{- тоже как и (++) соединяет списик. Но в более общем виде .
Т.к. может объединять несколько списков-}
concat :: [[a]] -> [a]
concat [] = []
concat (xs:xss) = xs ++ concat xss
{-
*Main> concat [ [1,2,3], [5,7,4]]
[1,2,3,5,7,4]
-}


concatMap :: (a -> [b]) -> [a] -> [b]
concatMap f xs = concat (map f xs)

{-
*Main> concatMap (\x -> [x,x,x]) [1,2,3]
[1,1,1,2,2,2,3,3,3]
-}