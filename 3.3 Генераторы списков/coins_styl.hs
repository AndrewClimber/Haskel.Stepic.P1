{-
Пусть есть список положительных достоинств монет coins, отсортированный по возрастанию. 
Воспользовавшись механизмом генераторов списков, напишите функцию change, которая разбивает переданную ей положительную 
сумму денег на монеты достоинств из списка coins всеми возможными способами. Например, если coins = [2, 3, 7]:

 
GHCi> change 7
[[2,2,3],[2,3,2],[3,2,2],[7]]

Примечание. Порядок монет в каждом разбиении имеет значение, то есть наборы [2,2,3] и [2,3,2] — различаются.
Список coins определять не надо.

-}


coins ::(Ord a, Num a) => [a]
--coins = [5,9,13]
coins = [2,3,7]
 
change :: (Ord a, Num a) => a -> [[a]]
change 0 = [[]]
change amount = [ c:cs |c<-coins, amount>=c, cs<-change (amount - c) ]

{-

Natasha Klaus
2 года назад
Ссылка
ШАГ 1. Первым делом, с помощью генератора списков создаю список, размер которого равен размеру списка монеток 
(если монетка не превосходит сумму, которую нужно разменять). Этот список списков и породит последующие списки. 
На каждой позиции в этом списке стоит уникальная монетка. Пока одна. 

т.е. если coins = [2,3,7] , а сумма к размену = 7, то инициализирующий список и будет = [ [2],[3],[7]]

ШАГ 2. Выращу этот список как дерево

Добавляю рекурсию: для каждого из полученных на первом шаге списков, вызываю change для неразмененного остатка. 

т.е. для списка [2] - мне нужно еще сумму 5 разменять набором coins.

Для [7] - это 0.

и т.д.

ШАГ 3. concatMap слепила все варианты, которые выросли из первого списка

ШАГ 4. Кайфую.
-}
change :: (Ord a, Num a) => a -> [[a]]
change a = concatMap ( helper ) [ [x] | x <- coins, sum [x] <= a ] where
	helper xs | sum xs == a = xs:[]
    helper xs | otherwise = map ( ++ xs) (change (a - sum xs) )
    
--------------------------------------------------------------
change :: (Ord a, Num a) => a -> [[a]]
change n
  | n <= 0 = [[]]
  | otherwise = [coin : m | coin <- coins, coin <= n, m <- change (n - coin)]
  
{-
Ссылка
Почти всегда в рекурсивных решениях вместо того, чтобы вставлять дополнительные проверки по ходу дела, достаточно 
аккуратно обработать граничные случаи.
Ноль можно набрать ровно одним способом — надо вернуть ничего. Если же сумма отрицательная, то никаких 
способов её набрать из монет положительного номинала не существует.
-}
change :: (Ord a, Num a) => a -> [[a]]
change n | n < 0     = []
         | n == 0    = [[]]
         | otherwise = [ x : xs | x <- coins, xs <- change (n - x) ]
