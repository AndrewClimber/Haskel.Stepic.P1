{-
Имеется возможность создавать бесконечные списки. И работать с ними.
Ленивая природа языка позволяет работать с такими структурами. Превратив бесконечную структуру в конечную.
Обрезав ее с помощью разных техник. Рассмотрим как можно бороться с расходимостями. И какие расходимости бывают.
Определим назывершающуюся программу :

Prelude> let bot = not bot

Prelude> :t bot
bot :: Bool
У нее нет ограничителя по рекурсии . И поэтому она выходит в бесконечный цикл.
 
Определим таким же способом бесконечный список. Список состоящий из единиц.
Prelude> let ones = 1 : ones

Prelude> :t ones
ones :: Num a => [a]
Эта программа расходящаяся. Но в отличие от bot , программа ones - является продуктивной. Т.е. что-то делает. Выводит 1 на экран.
Ленивая природа Haskell Позволяет работать с продуктивными расходящимися функциями довольно эффективно.

Определим ф-ю - которая генерирует бесконечный список натуральных чисел.
Prelude> let nats n = n: nats (n+1)
Prelude> :t nats
nats :: Num t => t -> [t]

В Haskell есть ф-и, которые могут брать часть списка.
Prelude> take 10 $ nats 5
[5,6,7,8,9,10,11,12,13,14]
И расходимость, благодаря ленивой природы вычислений, пропала.

Разберемся как это работает на примере более простой ф-и head
Prelude> let nats n = n: nats (n+1)
Prelude> head $ nats 42
42
Посмотрим какая последовательности редукций приводит к такому результату :
Определение ф-и nats - см. выше
Опредление ф-и head - ниже :
head (x:xs) = x
head [] = error "Empty list"

head $ nats 42  -- сопоставление с образцом в head
~> head (42 : nats (42+1)) -- подстановка определения head
~> 42

head $ nats ( 40+2 )  -- сопоставление с образцом в head
~> head (( 40+2 ) : nats (( 40+2 )+1)) -- подстановка определения head
~>  40+2 
~> 42

Пример :
Prelude> let squares = map (^2) $ nats 42
Prelude> :t squares
squares :: Num b => [b]

Prelude> take 10 $ squares
[1764,1849,1936,2025,2116,2209,2304,2401,2500,2601]

-}