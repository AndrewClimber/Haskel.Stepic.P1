{-
Рекурсиные определения функций над  на списками очень похожи. Часто реализуют одну и ту же схему рекурсии.
На пустом списке - реализуем терминирующее условие.
На непустом списке - разделяем список на голову и хвост, рекурсивно вызываем функцию над хвостом. А с головой 
делаем некую операцию.
Такую схему можно обобщить. Написать некую универсальную ф-ю.
-}
module Demo where
import Prelude hiding (foldr)

-- примеры трех конкретных функций.
-- которые используют рекурсию над списками.
-- схема рекурсии у всех 3-х одинаковая.
-- отличия два. Разные терминирующие значения. 0,1,[]
-- и различные бинарные операторы. +,*,++
sumList :: [Integer] -> Integer
sumList [] = 0
sumList (x:xs) = x + sumList xs

sumList' :: [Integer] -> Integer
sumList' xs = foldr (+) 0 xs -- вариант со сверткой.
{--- или так. безточечно. можно убрать xs справа и слева. справа стоит в крайней позиции 
и не используется нигде более-}
sumList''  = foldr (+) 0  



productList :: [Integer] -> Integer
productList [] = 1
productList (x:xs) = x * productList xs

concatList :: [[a]] -> [a]
concatList [] = []
concatList (x:xs) = x ++ concatList xs

-- попоробуем обобщить эти функции.
{-  b - терминирующее значение , последнее b такого же типа
    сворачивающая ф-я. ф-я 2-х аргументов над всеми элементами списка.
    1-й аргумент в ней - элемент нашего списка - тип a.
    2-й аргумент - результат рекурсивного вызова этой ф-и - тип b
    3-й - куда передаётся результат операции - тоже тип b (последний параметр)
-}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f ini [] = ini -- 1-е уравнение. случай пустого списка.
foldr f ini (x:xs) = x `f` foldr f ini xs -- 2-е уравнение. случай непустого списка
{-
Demo> sumList [1,2,3]
6
Demo Prelude> sumList'' [1,2,3]
6

*Demo Prelude> foldr (+) 0 [1,2,3]
6

Т.е. с помощью foldr можно реализовать все рекурсивные ф-и над списками, которые
реализуют данную схему рекурсии.
-}
