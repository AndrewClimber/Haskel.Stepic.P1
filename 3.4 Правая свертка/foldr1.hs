import Prelude hiding (foldr)
{-
в предыдущих примерах сворачивающая ф-я представляла собой простой встроенный оператор.
Однако сворачивающя ф-я бывает более сложная. И ее необходимо сконструировать.
Это можно сделать по разному. Разберем на примерах как можно строить сворачивающие функции.
-}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f ini [] = ini 
foldr f ini (x:xs) = x `f` foldr f ini xs 

-- Необходимо посчитать сумму квадратов положительных элементов списка.
sumPositiveSquares :: [Integer] -> Integer
-- надо реализовать с помощью свертки foldr
-- Поскольку суммирование - то ini - это ноль
-- а сворачивающую ф-ю сделаем по месту с помощью лямбда-функции
-- в функции два аргумента, т.к. (a -> b -> b)
-- x - это элемент списка, а s - это результат свертки хвоста списка. 
-- т.е. x - имеет типа a, s - тип b
-- если элемент списка положительный, то возведем его в квадрат и проссумируем
-- с аккумулятором s , а если элемент отрицательный, то ничего не делаем .Просто возвращаем
-- значение аккумулятора. Результат предыдущей свертки.
sumPositiveSquares = foldr (\x s -> if x > 0 then x^2 + s else s) 0
{-
*Main Prelude> sumPositiveSquares [1,-2,3]
10

Сворачивающую ф-ю можем сделать в виде лямбда-выражения. Но есть и другой способ.
Через where или let in
-}