{-
свертки берут списки и сворачивают его - возврящая какое-то значение.
Можно поставить обратную задачу. Взять значение и используя некую ф-ю сгенерировать список.

-}
module Demo where

unfold :: (b -> (a,b)) -> b -> [a]
unfold f ini = let (x,ini') =  f ini in
    x : unfold f ini'

iterate f = unfold (\x -> (x, f x))    

{-
*Demo> take 10 . Demo.iterate (^2) $ 2
[2,4,16,256,65536,4294967296,18446744073709551616,340282366920938463463374607431768211456,115792089237316195423570985008687907853269984665640564039457584007913129639936,13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096]
-}

{-
Непонятно. Почему второй параметр передается как $ 2

Ответ из чата https://t.me/learn_haskell_with_fsd : 

Потому что оператор композиции ожидает две функции, принимающие по одному параметру каждая. 
В данном случае фукнкции справа и слева это функции двух аргументов, но они частично применены, 
чтобы каждая из них ожидала один. 
$ как оператор применения с минимальным приоритетом говорит, 
что сначала из двух функций нужно сделать одну (композицию функций) 
а затем передать этой функции 2.
-}

{-
Для реализации ф-и unfold, которая генерит конечные списик нам надо познакомиться с типом данных Maybe
Этот тип данных нужен для расширения других типов данных одним дополнительным значением.
Которые выражают идею : значения отсутствуют.
Этот тип данных содержит два конструктора
1-й
Demo> :t Nothing
Nothing :: Maybe a
видим - что Maybe - тип с параметром
2-й
*Demo> :t Just
Just :: a -> Maybe a
этот конструктор имеет один параметр.
*Demo> :t Just True
Just True :: Maybe Bool
Maybe можно рассматривать как контейнер в котором либо ничего не лежит, либо одно какое-либо значение
Типа : [] и [_]

Maybe активно используется в стандартной библиотеке.
Prelude> import Data.List
Prelude Data.List> :t find
find :: Foldable t => (a -> Bool) -> t a -> Maybe a
эта ф-я принимает предикат. список. и ищет в списке значение удовлетворяющее предикату.
Результатом поиска могут быть две ситуации.
1. можем найти в списке значение удовлетворяющее предикату. Тогда это значение возвращается.
2. но значение может быть и не найдено.
Т.е. в первом случае возвращается значение упакованное в контейнер Just
Если поиск неудачен возвращается значение Nothing

Prelude Data.List> find odd [1,2,4]
Just 1
Prelude Data.List> find odd [4,2,4]
Nothing

Еще ф-я которая использует Maybe
Prelude Data.List> :t lookup
lookup :: Eq a => a -> [(a, b)] -> Maybe b

Prelude Data.List> lookup 2 [(2,'a'),(1,'b')]
Just 'a'
Prelude Data.List> lookup 3 [(2,'a'),(1,'b')]
Nothing
-}

unfoldr :: (b -> Maybe (a,b)) -> b -> [a]
unfoldr f ini = helper (f ini) where
    helper (Just (x, ini')) = x : unfoldr f ini'
    helper Nothing = []

-- another implementation  unfoldr
-- https://kseo.github.io/posts/2016-12-12-unfold-and-fold.html
unfoldr' :: (b -> Maybe (a, b)) -> (b -> [a])
unfoldr' f b = case f b of
                Just (a, b') -> a : unfoldr' f b'
                Nothing -> []    
{-
Prelude Data.List> unfoldr (\x -> if x == 10 then Nothing else Just (x,x+2)) 0
[0,2,4,6,8]
-}    